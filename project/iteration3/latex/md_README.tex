The robot simulator consists of 2 primary components\+: the {\itshape graphics\+\_\+area\+\_\+viewer} and {\itshape arena}. Robots and other similar entities live in the arena and are quite oblivious to being viewed by the viewer. The viewer is in control of everything in that it sends a message to the arena to update, meaning move the arena entities the appropriate amount given how much time has passed since the last update. It then gets the appropriate positional information from each entity and draws these to the screen. All the while, the system is listening for keyboard and mouse activity by the user. If any action occurs, the associated callback is executed.





Iteration 1 Requirements are in a separate document. This is a general overview of the framework.

An overview of classes is provided in {\itshape Project\+Class\+Overview.\+md}





\subsection*{Mechanics of the System}

\subsubsection*{Resources}


\begin{DoxyItemize}
\item libsimple\+\_\+graphics \+: \href{https://github.umn.edu/umn-csci-3081F17/libSimpleGraphics/}{\tt https\+://github.\+umn.\+edu/umn-\/csci-\/3081\+F17/lib\+Simple\+Graphics/}
\item nanogui \+: \href{https://github.com/wjakob/nanogui}{\tt https\+://github.\+com/wjakob/nanogui}
\item nanogui documentation\+: \href{https://nanogui.readthedocs.io/en/latest/}{\tt https\+://nanogui.\+readthedocs.\+io/en/latest/}
\item nanovg \+: \href{https://github.com/memononen/NanoVG}{\tt https\+://github.\+com/memononen/\+Nano\+VG}
\item Google Style Guide \+: \href{https://google.github.io/styleguide/cppguide.html}{\tt https\+://google.\+github.\+io/styleguide/cppguide.\+html}
\item cpplint \+: \href{https://github.com/google/styleguide/tree/gh-pages/cpplint}{\tt https\+://github.\+com/google/styleguide/tree/gh-\/pages/cpplint}
\item doxygen \+: \href{http://www.stack.nl/~dimitri/doxygen/}{\tt http\+://www.\+stack.\+nl/$\sim$dimitri/doxygen/}
\item Google Test \+: \href{https://github.com/google/googletest}{\tt https\+://github.\+com/google/googletest}
\end{DoxyItemize}

\subsubsection*{lib\+Simple\+Graphics and /project/f17c3081}

The arena viewer is a subclass of Graphics\+App, which can be found in the lib\+Simple\+Graphics repo. When building the simulator, the local object files are linked with lib\+Simple\+Graphics located at {\ttfamily /project/f17c3081}, which is publicly accessible on all cselabs machines. If you want to compile on your own platform, you will have to create a similar directory and change the makefile to reflect your local drive (i.\+e. edit the C\+S3081\+D\+IR variable in src/\+Makefile to point to the directory where lib\+Simple\+Graphics has been installed.)

\begin{quote}
{\bfseries Do not submit to your repo any of the code from lib\+Simple\+Graphics. Also, do not submit a makefile in which you are linking to your personal local directory -\/ it must refer to the cselabs directory.} \end{quote}


\subsubsection*{Directory Structure}

Makefile\+:
\begin{DoxyItemize}
\item make all and make clean for the whole project (calls make recursively in subdirs).
\end{DoxyItemize}

src/\+:
\begin{DoxyItemize}
\item the main source code where you will find robot\+\_\+viewer.\+h/cc and robot\+\_\+land.\+h/cc
\end{DoxyItemize}

src/\+Makefile\+:
\begin{DoxyItemize}
\item builds the project source, assumes it should build all .cc and .cpp files in the current directory
\item {\bfseries creates an executable in build/bin/exename}
\item uses auto dependency generation to get dependencies from \#includes
\end{DoxyItemize}

build/\+:
\begin{DoxyItemize}
\item created by the Makefiles
\end{DoxyItemize}

build/bin\+:
\begin{DoxyItemize}
\item {\bfseries all exes generated for the project go in here}
\end{DoxyItemize}

build/obj\+:
\begin{DoxyItemize}
\item all .o\textquotesingle{}s and .d\textquotesingle{}s (from make depend) go in here
\end{DoxyItemize}





\subsection*{Getting Started}


\begin{DoxyEnumerate}
\item {\itshape pull} the class repo.
\item cp the project to your personal repo
\item If you are working from your local machine, modify the {\ttfamily C\+S3081\+D\+IR} variable in {\ttfamily src/\+Makefile} so that it points to your local installation of lib\+Simple\+Graphics. Ignore this step if working on a C\+SE labs machine.
\item At the top level from the OS command prompt\+: {\ttfamily make}
\item Navigate to {\ttfamily build/bin}
\item At command prompt\+: {\ttfamily ./arenaviewer}
\end{DoxyEnumerate}

If you have trouble compiling, it might be that your account is behind on the gcc version. At the prompt, type {\ttfamily gcc -\/-\/version} and if it says 4.\+x, you need to load gcc\+: {\ttfamily module load /soft/gcc/7.1}. Check your $\sim$/.bashrc file. If you see a load for gcc, remove this. Then when you login, gcc 5.\+x will be the default.

There are more directions in lib\+Simple\+Graphics about getting things configured for your personal platform. Systems is working on a potential solution for remote access through vole.





\subsection*{Code explanation}

\subsubsection*{class Graphics\+App}

The Graphics\+App makes use of the nanogui, nanovg, and open\+GL libraries to create a window with 2D graphics and a G\+UI. As with most graphics applications, there is a main loop in which keyboard and mouse events are handled, then all objects in the graphics window are drawn. The loop is executed at the frame rate until the application is closed. The actual loop is hidden inside the library code, but it behaves something like this\+:


\begin{DoxyCode}
1 \{C++\}
2 while (Active(window)) \{  // ie user has not clicked 'x' to close the window
3   handleKeyMouseEvents();
4   clearScreen()   // start with a fresh screen/buffer
5   drawContents();
6   swapBuffers(window);    // double-buffered system
7 \}
\end{DoxyCode}


This loop is initiated by a call to nanogui\+::mainloop(), which you can find in Graphics\+App\+::\+Run().


\begin{DoxyCode}
1 \{C++\}
2 void GraphicsApp::Run() \{
3   glfwSetTime(0.0);
4   nanogui::mainloop();
5 \}
\end{DoxyCode}


Once that mainloop() is initiated, at the frame rate, Graphics\+App\+::draw() will be called. Notice the {\bfseries two very important function calls {\ttfamily Update\+Simulation()} and {\ttfamily Draw\+Using\+Nano\+V\+G()}}.


\begin{DoxyCode}
1 \{C++\}
2 void GraphicsApp::draw(NVGcontext *ctx) \{
3 
4   double now = glfwGetTime();
5   UpdateSimulation(now - last\_draw\_time\_);
6   last\_draw\_time\_ = now;
7 
8   // Draw the user interface using the nanogui library, which is built upon nanovg
9   Screen::draw(ctx);
10 
11   // Draw other vector graphics using the nanovg library
12   DrawUsingNanoVG(ctx);
13 \}
\end{DoxyCode}


\subsubsection*{class Graphics\+Arena\+Viewer in graphics\+\_\+arena\+\_\+viewer.\+h / .cc}

Robot\+Viewer is a subclass of Graphics\+App. In this application, it is instantiated in main() with the name {\itshape app}. Notice in the constructor of Robot\+Viewer, you see the instantiation of robot land. The simulator gets started with a call to app-\/$>$Run(), which calls nanogui\+::mainloop()\+:


\begin{DoxyCode}
1 \{C++\}
2 int main(int argc, char **argv) \{
3 
4   csci3081::InitGraphics();
5 
6   csci3081::GraphicsArenaViewer \(\backslash\)*app = new csci3081::GraphicsArenaViewer();
7   app->Run();
8 
9   csci3081::ShutdownGraphics();
10   return 0;
11 \}
\end{DoxyCode}


Recall that in the draw() function of the Graphics\+App, there is a call to Update\+Simulation() and Draw\+Using\+Nano\+V\+G(). {\bfseries Look at these function definitions in {\itshape graphics\+\_\+arena\+\_\+viewer.\+cc.}} All that is happening in Update is a call to the arena to update based on how much time has passed. In the draw function, each entity is being drawn. Notice that the graphics commands for drawing each of the objects begins with {\ttfamily nvg} for nanovg. The header file {\ttfamily \href{https://github.com/memononen/nanovg/blob/master/src/nanovg.h}{\tt https\+://github.\+com/memononen/nanovg/blob/master/src/nanovg.\+h}} is pretty well documented. Take a moment to look at this header file and read about some of the function calls that you see in drawing the various graphics objects (e.\+g. Draw\+Robot, Draw\+Obstacle).

(The keyboard and mouse event processing is discussed below.)

\subsubsection*{The Classes}

Arena has no awareness of the viewer, despite the fact that it was instantiated inside of the viewer. You can think about robots in the arena constantly moving around (even though they move in discrete steps), but periodically the viewer takes a snapshot of the situation and displays it on the screen. The viewer interacts with the arena through getters, which get information from each robot and each obstacle that is relevant to drawing them in the graphics window. It also sends commands from the user to control the robot.

Currently, the arena has a stationary obstacle, home base, recharging station, and a mobile robot. All of these entities are subclasses of either Arena\+Mobile\+Entity or Arena\+Immobile\+Entity, which in turn is a subclass of Arena\+Entity. The robot contains a battery, touch sensor, a motion handler for setting velocity, and motion behavior for calculating a new position at each update. These are all instantiations of distinct classes. There are parameter structures for the various entities for initialization. Finally, there are different types of event classes, including collision, keypress, recharge, and command. While not a true implementation of the Visitor pattern, these events are accepted by the arena or entities in the arena. All event classes are subclasses of the Event\+Base\+Class.

\subsubsection*{Keyboard and Mouse Event Handling}

Events are handled inside the viewer, because this manages all aspects of the G\+UI. Look in graphics\+\_\+area\+\_\+viewer.\+cc to see the various events to be handled (e.\+g. On\+Key\+Down(), which handles the down arrow key). The name gives an indication of which event it is responding to. When that event occurs, this is the function that is called. You never see the call to this function, but know that it does happen. Currently, for the most part, events are handled by printing messages to a terminal, but they really come in handy when you want the user to interact with the graphics window. For example, you might want the functionality that wherever the user clicks the mouse, a robot is created at that position.

The menu you see in the application with a reset and pause button was a custom menu made for this application. If you downloaded the nanogui examples, you saw how complex these menus can be. It is quite easy to add buttons with various functionality to the menu. Let\textquotesingle{}s trace that process through the code ...

It starts in the viewer constructor\+:


\begin{DoxyCode}
1 \{C++\}
2 nanogui::FormHelper *gui = new nanogui::FormHelper(this);
3 
4 nanogui::ref<nanogui::Window> window =
5     gui->addWindow(Eigen::Vector2i(10, 10), "Simulation Controls");
6 pause\_btn\_ =
7     gui->addButton("Pause", std::bind(&RobotViewer::OnPauseBtnPressed, this));
8 gui->addButton("Restart", std::bind(&RobotViewer::OnRestartBtnPressed, this));
\end{DoxyCode}


You start with the instantiation of Form\+Helper, then add the various components. The parameters being passed to the {\ttfamily add\+Button} are the name that appears on the button and the {\itshape callback} function, meaning the one that is called when the button is pressed (which is registered via a mouse click). Again, all of this is going on behind the scenes and you will not see an explicit call to the callback function.

\begin{quote}
Notice the special form of the comments. They are following doxygen formatting, \end{quote}
which when compiled for doxygen, generates the documentation in the form of a pdf or web pages. 