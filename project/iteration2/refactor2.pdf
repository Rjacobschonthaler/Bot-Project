	The only file that was chaged was arena.cc in the function Arena::CheckForEntityCollision. One variable name change was from ration to ratio_of_radii and the other was from ec to event_collision. The reasons for these changes are as follows. The ratio_of_radii change made it more clear at a glance what the ratio was for and how that played out in the computations that it is involved in. The event_collision change was because after vieweing the code for a while, I found myself rechecking what ec stood for, and it made it way easier to find all the places that it's used. The following changes are for ratio_of_radii:
Before:
  double ratio = ent1->get_radius()/ent2->get_radius();
    double collision_x = ent1_x+ratio*(ent1_x-ent2_x);
    double collision_y = ent1_y+ratio*(ent1_y-ent2_y);
After:
  double ratio_of_radii = ent1->get_radius()/ent2->get_radius();
    double collision_x = ent1_x+ratio_of_radii*(ent1_x-ent2_x);
    double collision_y = ent1_y+ratio_of_radii*(ent1_y-ent2_y);

The following changes are for event_collision:
Before:
  EventCollision ec;
  CheckForEntityCollision(player_, home_base_, &ec, player_->get_collision_delta());
  if (ec.get_collided()) {
    // R. Jacob Schonthaler added this for game completion
      std::cout << "You Win!" << std::endl;
      set_gameover(true);
  }

  /**
   * @brief Check if the player has collided with recharge station.
   */

  CheckForEntityCollision(player_, recharge_station_,
    &ec, player_->get_collision_delta());
  if (ec.get_collided()) {
    EventRecharge er;
    // er.EmitMessage();
    player_->Accept(&er);
  }

  /*
   * Finally, some pairs of entities may now be close enough to be considered
   * colliding, send collision events as necessary.
   *
   * When something collides with an immobile entity, the immobile entity does
   * not move (duh), so no need to send it a collision event.
   */
  for (auto ent : mobile_entities_) {
    // Check if it is out of bounds. If so, use that as point of contact.
    assert(ent->is_mobile());
    CheckForEntityOutOfBounds(ent, &ec);

    // If not at wall, check if colliding with any other entities (not itself)
    if (!ec.get_collided()) {
      for (size_t i = 0; i < entities_.size(); ++i) {
        if (entities_[i] == ent) {
          continue;
        }
        CheckForEntityCollision(ent, entities_[i], &ec, ent->get_collision_delta());
        if (ec.get_collided()) {
          break;
        }
      } /* for(i..) */
    } /* else */
    ent->Accept(&c);
  } /* for(ent..) */
After:
  EventCollision event_collision;
  CheckForEntityCollision(player_, home_base_, &event_collision, player_->get_collision_delta());
  if (event_collision.get_collided()) {
    // R. Jacob Schonthaler added this for game completion
      std::cout << "You Win!" << std::endl;
      set_gameover(true);
  }

  /**
   * @brief Check if the player has collided with recharge station.
   */

  CheckForEntityCollision(player_, recharge_station_,
    &event_collision, player_->get_collision_delta());
  if (event_collision.get_collided()) {
    EventRecharge er;
    // er.EmitMessage();
    player_->Accept(&er);
  }

  /*
   * Finally, some pairs of entities may now be close enough to be considered
   * colliding, send collision events as necessary.
   *
   * When something collides with an immobile entity, the immobile entity does
   * not move (duh), so no need to send it a collision event.
   */
  for (auto ent : mobile_entities_) {
    // Check if it is out of bounds. If so, use that as point of contact.
    assert(ent->is_mobile());
    CheckForEntityOutOfBounds(ent, &event_collision);

    // If not at wall, check if colliding with any other entities (not itself)
    if (!event_collision.get_collided()) {
      for (size_t i = 0; i < entities_.size(); ++i) {
        if (entities_[i] == ent) {
          continue;
        }
        CheckForEntityCollision(ent, entities_[i], &event_collision, ent->get_collision_delta());
        if (event_collision.get_collided()) {
          break;
        }
      } /* for(i..) */
    } /* else */
    ent->Accept(&event_collision);
  } /* for(ent..) */
